Объектно-ориентированное программирование (ООП) —
методология программирования, основанная на представлении программы
в виде совокупности объектов, каждый из которых является экземпляром
определённого класса, а классы образуют иерархию наследования.

Принципы ООП:
1. абстрагирование
   это принцип ООП, согласно которому объект характеризуется свойствами,
   которые отличают его от всех остальных объектов и при этом четко определяют
   его концептуальные границы.
   Т. е. абстракция позволяет:
   - Выделить главные и наиболее значимые свойства предмета.
   - Отбросить второстепенные характеристики.
2. наследование
   это способ создания нового класса на основе уже существующего,
   при котором класс-потомок заимствует свойства и методы родительского класса
   и также добавляет собственные. Отсюда - уменьшение дублирования кода.
3. инкапсуляция
   это принцип ООП, согласно которому сложность реализации программного
   компонента должна быть спрятана за его интерфейсом.
   Это сокрытие логики работы того или иного метода или класса.
   Язык Python реализует инкапсуляцию, но не предусматривает возможности
   сокрытия в принципе. В ООП инкапсуляция тесно связана с принципом абстракции данных.
   При этом:
   - Отсутствует доступ к внутреннему устройству программного компонента.
   - Взаимодействие компонента с внешним миром осуществляется посредством интерфейса,
     который включает публичные методы и поля.
4. полиморфизм
   Это способность функции обрабатывать данные разных типов.
   "Один интерфейс — много реализаций"

Класс — в ООП, представляет собой шаблон для создания объектов
Объект — некоторая сущность, обладающая определённым состоянием и поведением,
имеющая определенные свойства (атрибуты) и операции над ними (методы)

Атрибуты класса можно разделить на встроенные и пользовательские

Служебное слово self - это ссылка на текущий экземпляр класса.
Как правило, эта ссылка передается в качестве первого параметра метода Python

Методы класса можно разделить на 3 группы:
- Методы экземпляра класса (они же обычные методы)
  Это группа методов, которые становятся доступны
  только после создания экземпляра класса,
  то есть чтобы вызвать такой метод, надо обратиться к экземпляру.
  Как следствие - первым параметром такого метода является слово self.
  С помощью данного параметра в метод передается ссылка на объект класса,
  для которого он был вызван.
- Статические методы
  Это обычные функции, которые помещены в класс для удобства и
  тем самым располагаются в области видимости этого класса.
  Важная особенность заключается в том, что данные методы можно
  вызывать посредством обращения к имени класса,
  создавать объект класса при этом не обязательно.
  Именно поэтому в таких методах не используется self -
  этому методу не важна информация об объектах класса.
  Чтобы создать статический метод в Python,
  необходимо воспользоваться специальным декоратором - @staticmethod.
- Методы класса
  Методы класса являются чем-то средним между обычными методами
  (привязаны к объекту) и статическими методами (привязаны только к области видимости).
  Такие методы могут менять состояние самого класса,
  что в свою очередь отражается на ВСЕХ экземплярах данного класса.
  Чтобы создать метод класса, необходимо воспользоваться соответствующим декоратором -
  @classmethod. При этом в качестве первого параметра такого метода
  передается служебное слово cls, которое в отличие от self является ссылкой на
  сам класс (а не на объект).

Унарные операторы и функции имеют только один операнд —
отрицание, абсолютное значение, и так далее.

Уровни доступа атрибутов в Python

- Private.
  Приватные члены класса недоступны извне -
  с ними можно работать только внутри класса.
- Public.
  Публичные методы наоборот - открыты для работы снаружи и,
  как правило, объявляются публичными сразу по-умолчанию.
- Protected.
  Доступ к защищенным ресурсам класса возможен только внутри этого класса
  и также внутри унаследованных от него классов
  (иными словами, внутри классов-потомков). Больше никто доступа к ним не имеет

В Питоне функции являются объектами первого класса.
Это означает, что они могут быть переданы в функции или методы так же,
как любые другие объекты.

Дескрипторы это такие классы, с помощью которых можно добавить свою логику
к событиям доступа (получение, изменение, удаление) к атрибутам других объектов.
Чтобы класс стал дескриптором, он должен реализовать по крайней мере один метод
из __get__, __set__ или __delete__.

Магические методы в Питоне

1. __new__(cls, [..)
   Это первый метод, который будет вызван при инициализации объекта.
   Он принимает в качестве параметров класс и потом любые другие аргументы,
   которые будут переданы в __init__.
2. __init__(self, [..)
   Инициализатор класса. Ему передаётся всё, с чем был вызван первоначальный конструктор
3. __del__(self)
   Деконструктор класса.
4. __eq__(self, other)
   Определяет поведение оператора равенства, ==
5. __cmp__(self, other)
   Самый базовый из методов сравнения.
   Он определяет поведение для всех операторов сравнения (>, ==, !=, итд.)
6. __ne__(self, other)
   Определяет поведение оператора неравенства, !=
7. __lt__(self, other)
   Определяет поведение оператора меньше, <
8. __gt__(self, other)
   Определяет поведение оператора больше, >
9. __le__(self, other)
   Определяет поведение оператора меньше или равно, <=
10. __ge__(self, other)
    Определяет поведение оператора больше или равно, >=
11. __pos__(self)
    Определяет поведение для унарного плюса (+some_object)
12. __neg__(self)
    Определяет поведение для отрицания(-some_object)
13. __abs__(self)
    Определяет поведение для встроенной функции abs()
14. __invert__(self)
    Определяет поведение для инвертирования оператором ~
15. __round__(self, n)
    Определяет поведение для встроенной функции round().
    n это число знаков после запятой, до которого округлить
16. __floor__(self)
    Определяет поведение для math.floor(), то есть,
    округления до ближайшего меньшего целого
17. __ceil__(self)
    Определяет поведение для math.ceil(), то есть,
    округления до ближайшего большего целого
18. __trunc__(self)
    Определяет поведение для math.trunc(), то есть, обрезания до целого
19. __add__(self, other)
    Сложение
20. __sub__(self, other)
    Вычитание
21. __mul__(self, other)
    Умножение
22. __floordiv__(self, other)
    Целочисленное деление, оператор
23. __div__(self, other)
    Деление, оператор /
24. __truediv__(self, other)
    Правильное деление.
    Работает только когда используется from __future__ import division
25. __mod__(self, other)
    Остаток от деления, оператор %
26. __divmod__(self, other)
    Определяет поведение для встроенной функции divmod()
27. __pow__
    Возведение в степень, оператор **
28. __lshift__(self, other)
    Двоичный сдвиг влево, оператор <<
29. __rshift__(self, other)
    Двоичный сдвиг вправо, оператор >>
30. __and__(self, other)
    Двоичное И, оператор &
31. __or__(self, other)
    Двоичное ИЛИ, оператор |
32. __xor__(self, other)
    Двоичный xor, оператор ^
33. __radd__(self, other)
    Отражённое сложение
34. __rsub__(self, other)
    Отражённое вычитание
35. __rmul__(self, other)
    Отражённое умножение
36. __rfloordiv__(self, other)
    Отражённое целочисленное деление, оператор //
37. __rdiv__(self, other)
    Отражённое деление, оператор /
38. __rtruediv__(self, other)
    Отражённое правильное деление.
    Работает только когда используется from __future__ import division
39. __rmod__(self, other)
    Отражённый остаток от деления, оператор %
40. __rdivmod__(self, other)
    Определяет поведение для встроенной функции divmod(),
    когда вызывается divmod(other, self)
41. __rpow__
    Отражённое возведение в степерь, оператор **
42. __rlshift__(self, other)
    Отражённый двоичный сдвиг влево, оператор <<
43. __rrshift__(self, other)
    Отражённый двоичный сдвиг вправо, оператор >>
44. __rand__(self, other)
    Отражённое двоичное И, оператор &
45. __ror__(self, other)
    Отражённое двоичное ИЛИ, оператор |
46. __rxor__(self, other)
    Отражённый двоичный xor, оператор ^
47. __iadd__(self, other)
    Сложение с присваиванием
48. __isub__(self, other)
    Вычитание с присваиванием
50. __imul__(self, other)
    Умножение с присваиванием
51. __ifloordiv__(self, other)
    Целочисленное деление с присваиванием, оператор //=
52. __idiv__(self, other)
    Деление с присваиванием, оператор /=
53. __itruediv__(self, other)
    Правильное деление с присваиванием.
    Работает только если используется from __future__ import division
54. __imod_(self, other)
    Остаток от деления с присваиванием, оператор %=
55. __ipow__
    Возведение в степерь с присваиванием, оператор **=
56. __ilshift__(self, other)
    Двоичный сдвиг влево с присваиванием, оператор <<=
57. __irshift__(self, other)
    Двоичный сдвиг вправо с присваиванием, оператор >>=
58. __iand__(self, other)
    Двоичное И с присваиванием, оператор &=
59. __ior__(self, other)
    Двоичное ИЛИ с присваиванием, оператор |=
60. __ixor__(self, other)
    Двоичный xor с присваиванием, оператор ^=
61. __int__(self)
    Преобразование типа в int
62. __long__(self)
    Пребразование типа в long
63. __float__(self)
    Преобразование типа в float
64. __complex__(self)
    Преобразование типа в комплексное число
65. __oct__(self)
    Преобразование типа в восьмеричное число
66. __hex__(self)
    Преобразование типа в шестнадцатиричное число
67. __index__(self)
    Преобразование типа к int, когда объект используется в срезах
    (выражения вида [start:stop:step]). Если определяем свой числовый тип,
    который может использоваться как индекс списка, то должны определить __index__
68. __trunc__(self)
    Вызывается при math.trunc(self).
    Должен вернуть своё значение, обрезанное до целочисленного типа (обычно long)
69. __coerce__(self, other)
    Метод для реализации арифметики с операндами разных типов.
    __coerce__ должен вернуть None если преобразование типов невозможно.
    Если преобразование возможно, он должен вернуть пару
    (кортеж из 2-х элементов) из self и other, преобразованные к одному типу.
70. __str__(self)
    Определяет поведение функции str(), вызванной для экземпляра класса
71. __repr__(self)
    Определяет поведение функции repr(), вызыванной для экземпляра класса.
    Главное отличие от str() в целевой аудитории.
    repr() больше предназначен для машинно-ориентированного вывода
    (более того, это часто должен быть валидный код на Питоне),
    а str() предназначен для чтения людьми
72. __unicode__(self)
    Определяет поведение функции unicode(), вызыванной для экземпляра класса.
    unicode() похож на str(), но возвращает строку в юникоде.
    Будте осторожны: если клиент вызывает str() на экземпляре класса,
    а вы определили только __unicode__(), то это не будет работать.
    Постарайтесь всегда определять __str__() для случая,
    когда кто-то не имеет такой роскоши как юникод
73. __format__(self, formatstr)
    Определяет поведение, когда экземпляр класса используется
    в форматировании строк нового стиля.
    Например, "Hello, {0:abc}!".format(a) приведёт к вызову a.__format__("abc").
    Это может быть полезно для определения ваших собственных числовых
    или строковых типов, которым вы можете захотеть предоставить
    какие-нибудь специальные опции форматирования
74. __hash__(self)
    Определяет поведение функции hash(), вызыванной для экземпляра класса.
    Метод должен возвращать целочисленное значение,
    которое будет использоваться для быстрого сравнения ключей в словарях.
    Заметьте, что в таком случае обычно нужно определять и __eq__ тоже.
    Руководствуйтесь следующим правилом: a == b подразумевает hash(a) == hash(b)
75. __nonzero__(self)
    Определяет поведение функции bool(), вызванной для экземпляра класса.
    Должна вернуть True или False, в зависимости от того,
    когда вы считаете экземпляр соответствующим True или False
76. __dir__(self)
    Определяет поведение функции dir(), вызванной на экземпляре класса.
    Этот метод должен возвращать пользователю список атрибутов.
    Обычно, определение __dir__ не требуется, но может быть жизненно важно
    для интерактивного использования класса, если вы переопределили
    __getattr__ или __getattribute__, или каким-либо другим образом
    динамически создаёте атрибуты
77. __sizeof__(self)
    Определяет поведение функции sys.getsizeof(), вызыванной на экземпляре класса.
    Метод должен вернуть размер объекта в байтах.
    Он главным образом полезен для классов, определённых в расширениях на C,
    но всё-равно полезно о нём знать
78. __getattr__(self, name)
    Вы можете определить поведение для случая,
    когда пользователь пытается обратиться к атрибуту,
    который не существует (совсем или пока ещё).
    Это может быть полезным для перехвата и перенаправления частых опечаток,
    предупреждения об использовании устаревших атрибутов
    (вы можете всё-равно вычислить и вернуть этот атрибут, если хотите),
    или хитро возвращать AttributeError, когда это вам нужно.
    Правда, этот метод вызывается только когда пытаются получить доступ
    к несуществующему атрибуту, поэтому это не очень хорошее решение для инкапсуляции.
79. __setattr__(self, name, value)
    В отличии от __getattr__, __setattr__ решение для инкапсуляции.
    Этот метод позволяет определить поведение для присвоения значения атрибуту,
    независимо от того существует атрибут или нет.
    То есть, вы можете определить любые правила для любых изменений значения атрибутов.
80. __delattr__
    Это то же, что и __setattr__, но для удаления атрибутов,
    вместо установки значений. Здесь требуются те же меры предосторожности,
    что и в __setattr__ чтобы избежать бесконечной рекурсии
    (вызов del self.name в определении __delattr__ вызовет бесконечную рекурсию)
81. __getattribute__(self, name)
    __getattribute__ выглядит к месту среди своих коллег __setattr__ и __delattr__,
    но я бы не рекомендовал вам его использовать.
    __getattribute__ может использоваться только с классами нового типа
    (в новых версиях Питона все классы нового типа,
    а в старых версиях вы можете получить такой класс унаследовавшись от object).
    Этот метод позволяет вам определить поведение для каждого случая доступа
    к атрибутам (а не только к несуществующим, как __getattr__(self, name)).
    Он страдает от таких же проблем с бесконечной рекурсией,
    как и его коллеги (на этот раз вы можете вызывать __getattribute__ у
    базового класса, чтобы их предотвратить). Он, так же,
    главным образом устраняет необходимость в __getattr__,
    который в случае реализации __getattribute__ может быть вызван только
    явным образом или в случае генерации исключения AttributeError.
    Вы конечно можете использовать этот метод (в конце концов, это ваш выбор),
    но я бы не рекомендовал, потому что случаев, когда он действительно
    полезен очень мало (намного реже нужно переопределять поведение при получении,
    а не при установке значения) и реализовать его без возможных ошибок очень сложно.
82. __len__(self)
    Возвращает количество элементов в контейнере.
    Часть протоколов для изменяемого и неизменяемого контейнеров
83. __getitem__(self, key)
    Определяет поведение при доступе к элементу,
    используя синтаксис self[key]. Тоже относится и к протоколу изменяемых
    и к протоколу неизменяемых контейнеров. Должен выбрасывать
    соответствующие исключения: TypeError если неправильный тип ключа и
    KeyError если ключу не соответствует никакого значения
84. __setitem__(self, key, value)
    Определяет поведение при присваивании значения элементу,
    используя синтаксис self[nkey] = value. Часть протокола изменяемого контейнера.
    Опять же, вы должны выбрасывать KeyError и TypeError в соответсвующих случаях
85. __delitem__(self, key)
    Определяет поведение при удалении элемента (то есть del self[key]).
    Это часть только протокола для изменяемого контейнера.
    Вы должны выбрасывать соответствующее исключение, если ключ некорректен
86. __iter__(self)
    Должен вернуть итератор для контейнера.
    Итераторы возвращаются в множестве ситуаций, главным образом
    для встроенной функции iter() и в случае перебора элементов
    контейнера выражением for x in container:.
    Итераторы сами по себе объекты и они тоже должны определять метод __iter__,
    который возвращает self
87. __reversed__(self)
    Вызывается чтобы определить поведения для встроенной функции reversed().
    Должен вернуть обратную версию последовательности.
    Реализуйте метод только если класс упорядоченный, как список или кортеж.
88. __contains__(self, item)
    __contains__ предназначен для проверки принадлежности элемента с
    помощью in и not in. Вы спросите, почему же это не часть
    протокола последовательности? Потому что когда __contains__ не определён,
    Питон просто перебирает всю последовательность элемент за элементом и
    возвращает True если находит нужный
89. __missing__(self, key)
    __missing__ используется при наследовании от dict.
    Определяет поведение для для каждого случая, когда пытаются получить
    элемент по несуществующему ключу (так, например, если у меня есть словарь
    d и я пишу d["george"] когда "george" не является ключом в словаре,
    вызывается d.__missing__("george")).
90. __instancecheck__(self, instance)
    Проверяет, является ли экземлпяр членом вашего класса
    (isinstance(instance, class).
91. __subclasscheck__(self, subclass)
    Проверяет, является наследуется ли класс от вашего класса
    (issubclass(subclass, class))
92. __call__(self, [args...])
    Позволяет любому экземпляру вашего класса быть вызванным как-будто он функция.
    Главным образом это означает, что x() означает то же, что и x.__call__().
    __call__ принимает произвольное число аргументов; то есть,
    вы можете определить __call__ так же как любую другую функцию,
    принимающую столько аргументов, сколько вам нужно
93. __enter__(self)
    Определяет, что должен сделать менеджер контекста в начале блока,
    созданного оператором with. Возвращаемое __enter__ значение и есть то значение,
    с которым производится работа внутри with
94. __exit__(self, exception_type, exception_value, traceback)
    Определяет действия менеджера контекста после того,
    как блок будет выполнен (или прерван во время работы).
    Может использоваться для контроллирования исключений, чистки,
    любых действий которые должны быть выполнены незамедлительно после
    блока внутри with. Если блок выполнен успешно, exception_type, exception_value,
    и traceback будут установлены в None. В другом случае вы сами выбираете,
    перехватывать ли исключение или предоставить это пользователю;
    если вы решили перехватить исключение, убедитесь, что __exit__ возвращает
    True после того как всё сказано и сделано. Если вы не хотите,
    чтобы исключение было перехвачено менеджером контекста,
    просто позвольте ему случиться
95. __get__(self, instance, owner)
    Определяет поведение при возвращении значения из дескриптора.
    instance это объект, для чьего атрибута-дескриптора вызывается метод.
    owner это тип (класс) объекта.
96. __set__(self, instance, value)
    Определяет поведение при изменении значения из дескриптора.
    instance это объект, для чьего атрибута-дескриптора вызывается метод.
    value это значение для установки в дескриптор
97. __delete__(self, instance)
    Определяет поведение для удаления значения из дескриптора.
    instance это объект, владеющий дескриптором
98. __copy__(self)
    Определяет поведение copy.copy() для экземпляра вашего класса.
    copy.copy() возвращает поверхностную копию вашего объекта — это означает,
    что хоть сам объект и создан заново, все его данные ссылаются на
    данные оригинального объекта. И при изменении данных нового объекта,
    изменения будут происходить и в оригинальном
99. __deepcopy__(self, memodict={})
    Определяет поведение copy.deepcopy() для экземпляров вашего класса.
    copy.deepcopy() возвращает глубокую копию вашего объекта —
    копируются и объект и его данные. memodict это кэш предыдущих
    скопированных объектов, он предназначен для оптимизации копирования и
    предотвращения бесконечной рекурсии, когда копируются рекурсивные
    структуры данных. Когда вы хотите полностью скопировать какой-нибудь
    конкретный атрибут, вызовите на нём copy.deepcopy() с первым параметром
    memodict
100. __getinitargs__(self)
     Если вы хотите, чтобы после десериализации вашего класса был вызыван __init__,
     вы можете определить __getinitargs__, который должен вернуть кортеж аргументов,
     который будет отправлен в __init__. Заметьте, что этот метод работает только
     с классами старого стиля
101. __getnewargs__(self)
     Для классов нового стиля вы можете определить, какие параметры будут переданы
     в __new__ во время десериализации. Этот метод так же должен вернуть кортеж
     аргументов, которые будут отправлены в __new__
102. __getstate__(self)
     Вместо стандартного атрибута __dict__, где хранятся атрибуты класса,
     вы можете вернуть произвольные данные для сериализации.
     Эти данные будут переданы в __setstate__ во время десериализации
103. __setstate__(self, state)
     Если во время десериализации определён __setstate__,
     то данные объекта будут переданы сюда, вместо того чтобы просто записать
     всё в __dict__. Это парный метод для __getstate__:
     когда оба определены, вы можете представлять состояние вашего объекта так,
     как вы только захотите
104. __reduce__(self)
     Если вы определили свой тип (с помощью Python's C API),
     вы должны сообщить Питону как его сериализовать, если вы хотите,
     чтобы он его сериализовал. __reduce__() вызывается когда сериализуется объект,
     в котором этот метод был определён. Он должен вернуть или строку,
     содержащую имя глобальной переменной, содержимое которой сериализуется
     как обычно, или кортеж. Кортеж может содержать от 2 до 5 элементов:
     вызываемый объект, который будет вызван, чтобы создать десериализованный
     объект, кортеж аргументов для этого вызываемого объекта, данные,
     которые будут переданы в __setstate__ (опционально), итератор списка
     элементов для сериализации (опционально) и итератор словаря элементов
     для сериализации (опционально)
105. __reduce_ex__(self, protocol)
     Иногда полезно знать версию протокола, реализуя __reduce__.
     И этого можно добиться, реализовав вместо него __reduce_ex__.
     Если __reduce_ex__ реализован, то предпочтение при вызове отдаётся
     ему (вы всё-равно должны реализовать __reduce__ для обратной совместимости)

Так как в Питоне 3 различий между строкой и юникодом больше нет,
__unicode__ исчез, а появился __bytes__
(который ведёт себя так же как __str__ и __unicode__ в 2.7)
для новых встроенных функций построения байтовых массивов.

Так как деление в Питоне 3 теперь по-умолчанию «правильное деление»,
__div__ больше нет.

__coerce__ больше нет, из-за избыточности и странного поведения.

__cmp__ больше нет, из-за избыточности.

__nonzero__ было переименовано в __bool__.

next у итераторов был переименован в __next__

Django основан на шаблоне MVT (model-view-template),
что означает шаблон представления модели.

В основном используется два типа представлений:
- представления на основе функций (FBV)
- представления на основе классов (CBV)

FBV
В основе FBV лежат обычные функции, принимающие на входе запрос
(объект класса HttpRequest) и возвращающие ответ (объект класса HttpResponse
или ему подобных).

Преимущества FBV:
- Легко реализовать, прочитать и понять.
- Явный поток кода.
- Декоратор можно легко реализовать.
- Подходят для одноразовой или специализированной функциональности.
- Помогают понять основную концепцию Django.

Минусы FBV приведены ниже:
- Избыточность кода – самая большая проблема FBV.
- Условие ветвления будет использоваться для обработки HTTP-запроса.
- Код сложно расширить.

Пример:
    def create_view(request, pk):
        template_name = 'form.html'
        form_class = MyForm

        form = form_class

        if request.method == 'POST':
            form = form_class(request.POST)
            if form.is_valid():
                form.save()
                return HttpResponseRedirect(reverse('list-view'))

        return render(request, template_name, {'form': form})

CBV
CBV реализован в проекте в виде объектов Python, а не функций.
Это не замена FBV, но они обеспечивают преимущества по сравнению с
представлениями, основанными на функциях. Уменьшают повторение кода и
берут на себя основные операции, такие как удаление и добавление элементов.

Приемущества:
- Одно из самых больших преимуществ CBV – это наследование.
  CBV позволяет нам наследовать другой класс и может быть изменен
  для различных вариантов использования.
- Поддерживают принцип DRY. Это предотвращает повторение кода.
  Повторное использование кода также возможно в представлениях на основе классов.
- Универсальные представления-классы являются встроенными.
- Представления на основе классов обеспечивают правильную структуру кода.
  Мы можем использовать другой метод экземпляра класса (вместо оператора
  условного ветвления внутри функциональных представлений) для генерации
  HTTP-запросов.

Недостатки:
- Трудно понять, какой комплекс реализовать.
- Неявный поток кода.
- В декораторах представлений требуется дополнительный импорт или
  переопределение метода.

Пример:
    class MyCreateView(View):
        template_name = 'form.html'
        form_class = MyForm

        def get(self, request, *args, **kwargs):
            form = self.form_class
            return render(request, template_name, {'form': form})

        def post(self, request, *args, **kwargs):
            form = self.form_class(request.POST)
            if form.is_valid():
                form.save()
                return HttpResonseRedirect(reverse('list-view'))
            else:
                return render(request, self.template_name, {'form': form})

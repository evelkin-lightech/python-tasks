Auth

1. Что нужно сделать, чтобы переопределить стандартную модель Django User?

Существуют 4 способа для расширения стандартной модели Django User:
- использование прокси-модели
- использование связи один-к-одному с пользовательской моделью
- создание модели пользователя с помощью расширения класса AbstractBaseUser
- создание модели пользователя с помощью расширения класса AbstractUser

Использование прокси-модели
Это модель отнаследованная от уществующей модели пользователя без создания новой
табицы в базе данных. Она может быть использована тогда, когда нам необходимо
расширить существующую модель пользователя (например: добавление новых методов,
параметров сотртировки, изменить ее manager), но не затрагивающих схему базы данных.
Быстрый старт:
- создаем новое приложение User
- регистрируем его в settings APP
- создаем модель Person(User) и в классе Meta указываем proxy = True
- после чего можно создавать файл миграции и применить все миграции проекта

Использование связи один-к-одному с пользовательской моделью
В этом случае создается модель данных со своей собственной таблицей в базе данных,
оторая будет связана с существующей моделью пользователя один к одному.
Такую модель удобно использовать, когда нужно хранить дополнительную
информацию о пользователе, которая не связана с процессом аутентификации.
Такую модель чаще всего называют "профилем пользователя".
Быстрый старт:
- создается модель Profile
- для связи с моделью User используется user = models.OneToOneFiled(User)
- могут быть дополнены другие поля
- а далее, устаналиваются сигналы для автоматического обновления и создания
данной модели (но можно и без них, все делается методами User модели)

Создание модели пользователя с помощью расширения класса AbstractBaseUser
Это модель подразумевает создание новой модели, которая наследуется от
AbstractBaseUser модели. Также, дополнительно необходимо обновить некоторые
зависимости в settings.py файле. Использование данного метода подходит в тех
случаях, когда необходимо переопределить механизм или параметры аутентификации
пользователя в приложении. Считается одним из самых сложных и рекомендуют избегать
его.
Быстрый старт:
- создается новая модель User, которая наследуется от AbstractBaseUser и
PermissionsMixin
- так же описывается необходимый набор полей, обязательных полей, методов,
UserManager
- в файле settings.py указывается AUTH_USER_MODEL

Создание модели пользователя через расширение AbstractUser
Используется по аналогии как и в случае с наследованием от AbstractBaseUser.
Этот способ так же подразумевает создание новой модели. Наследуется от AbstractUser
Быстрый старт:
- новая модель наследуется от AbstractUser
- в файле settings.py указыввается AUTH_USER_MODEL


2. За что отвечает REQUIRED_FIELDS?
REQUIRED_FIELDS — список имен полей, которые будут запрашиваться при
создании пользователя через команду управления
Пример: python manage.py createsuperuser


3. За что отвечает USERNAME_FIELD?
USERNAME_FIELD — строка, описывающая имя поля в модели пользователя,
которая используется как идентификатор. Поле должно быть уникальным
(то есть иметь значение unique=True, установленное в его определении)


4. Зачем нужен ModelManager objects у модели User?
Manager - это интерфейс, через который для моделей Django предоставляются
операции запросов к базе данных. По крайней мере, один Manager существует
для каждой модели в приложении Django.

После того как вы создали модели данных, Django автоматически предоставляет
вам API-интерфейс для базы данных, который позволяет создавать, извлекать,
обновлять и удалять объекты.

По умолчанию Django добавляет Manager с именем objects в каждый класс модели
Django. Однако, если мы хотим использовать objects в качестве имени поля или
если мы хотим использовать имя, отличное от objects для Manager,
мы можем переименовать его для каждой модели.
Пример:
from django.db import models

class Person(models.Model):
    #...
    people = models.Manager()

Person.people.all()

Так же, имеется возможность создавать свои менеджеры, которые будут возвращать
нужные данные. Для этого нужно просто переопределить стандартный менеджер и
назначить новый функционал.
Пример:
class FantasyManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(action='fantasy')

class Book(models.Model):
    some_filed = ...

    fantasy = FantasyManager()

Book.fantasy.all()


5. За что отвечает настройка AUTH_USER_MODEL?
Это модель, используемая для представления Пользователя.
По умолчанию: 'auth.User'

Эта точечная пара описывает имя приложения Django
(которое должно быть в INSTALLED_APPS), и имя модели Django,
которую вы хотите использовать в качестве модели пользователя.


6. Если мы хотим создать ForeignKey на пользовательскую модель,
как это сделать- что указать в качестве to='ModelName'?
ForeignKey это отношение один ко многим или многие к одному.
Он принимает 2 позиционных аргумента: это класс к которому относится модель и
on_delete опция.
Если мы хотим указать на пользовательскую модель, то необходимо:
    from django.conf import settings
    ...
    ...ForeignKey(settings.AUTH_USER_MODEL)

или

    from django.contrib.auth.models import User
    ...
    ...ForeignKey(User)


7. `is_staff` за что отвечает данное поле?
Это некий флаг, который присутствует у Пользователя. Вообще флаги определяют
положение, некий статус Пользователя в системе.
Он отвечает за следующее, что Пользователь, у которого данный флаг установлен в
True имеет только явно выданные права. Простыми словами, данный флаг определяет
доступ к админке и, таким образом, указывает, можешь ли Пользователь в
рамках админки использовать те permissions, что ему назначены.


8. `is_superuser` за что отвечает данное поле и в чем отличие о `is_sutff`?
Это тоже флаг-статус, который определяет положение Пользователя в системе.
Он говорит, что Пользователь является суперюзером и имеет право на
создание/редактирование/удаление всех объектов в системе.
При создании суперпользователя `is_superuser` и `is_sutff` автоматически
будут True. Если у Пользователя есть флаг is_superuser, то у него есть
все permissions, которые в системе есть, и даже те, которых нет
(has_perm() возвращает всегда True).


9. Будет ли пользователь иметь доуступ в админку для следующих комбинаций:
 - is_stuff = True, is_superuser = True is_active=True (да)
 - is_stuff = True, is_superuser = True is_active=False (нет - учетка заблокирована)
 - is_stuff = True, is_superuser = False is_active=True (да - только доступ согласно назначенным premmis)
 - is_stuff = False, is_superuser = True is_active=True (нет)
 - is_stuff = False, is_superuser = False is_active=True (нет)
 - is_stuff = False, is_superuser = True is_active=False (нет)


10. Как создать объект пользователя через shell?
user@host> manage.py shell
>>> from django.contrib.auth.models import User
>>> user=User.objects.create_user('foo', password='bar')
>>> user.is_superuser=True
>>> user.is_staff=True
>>> user.save()


11. Достаточно ли иметь `email = models.EmailField(unique=True, blank=True)`
для `USERNAME_FIELD = ''`?
Нет, если речь идет об переопределении модели пользователя путем наследования
от абстрактных классов
нужно в модель добавить:
    email = models.EmailField(unique=True, blank=True)
    username = None
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = []


12. Какое приложение в django отвечает за модуль аутентификации
Djnago из коробки предоставляет разработчику возможность добавлять
систему аутентификации в свои приложения - это приложение auth.
Аутентификация простыми словами это проверка подлинности.
Авторизация — предоставление определённому лицу или группе лиц прав на
выполнение определённых действий (premissions).
Приложение аутентификации Django предоставляет следующие функциональные
возможности:
- Класс авторизации LoginView,
- Класс выхода LogoutView,
- Сброс пароля PasswordResetView,
- Смена пароля PasswordChangeView.

Для того, чтобы разработчик смог воспользоваться данным модулем, в настройках
в разделе INSTALLED_APPS должен быть включен этот самый модуль:
'django.contrib.auth', а так же в MIDDLEWARE -
'django.contrib.auth.middleware.AuthenticationMiddleware'


13. Если мы не знаем проекта, но хотим импортировать текущю модель
аутентификации укакзанную на уровне settings (импортировать именно класс),
как нам это сделать?
На уровне settings есть настройка AUTH_USER_MODEL, котрая по умолччанию
будет 'auth.User'. В случае, если она переопределена, то мы получим текущий
класс представления пользователя, используя эту настроку.

Импорт будет выглядеть следующим образом:
from django.conf import settings

а в самом коде необходимо обращаться к настройке модуля:
setting.AUTH_USER_MODEL


14. Как задается пароль пользователю через код?
Django не хранит необработанные (открытым текстом) пароли в
пользовательской модели, а только хэш.
Поэтому при создании пользователя используется вспомогательная функция.
Чтобы изменить пароль пользователя, есть несколько вариантов:
python manage.py chengepassword sam

Можно изменить пароль программно, через код:
>>> from django.contrib.auth.models import User
>>> u = User.objects.get(username='john')
>>> u.set_password('new password')
>>> u.save()

Если есть админ-панель, то можно воспользоваться ей и сменить пароль.


15. В случае если мы хотим реализовать свою модель User, какие существуют
особенности в настройке админ панели для данной модели?
Когда мы создаем класс для админ-панели, мы пользуемся ModelAdmin из
django.contrib.admin модуля.
Для пользователя, если мы создаем свою модель, мы можем воспользоваться
классом UserAdmin, отнаследовавшись от него, и определив или переопределив
собственные поля. Тем самым есть возможность не "изобретать велосипеда", а просто
расширить функционал админ-панели.

Но это еще не все: согласно официальной документации,
- если пользовательская модель расширяет AbstractUser,
то можно использовать существующий класс Django
django.contrib.auth.admin.UserAdmin
- однако, если пользовательская модель расширяет AbstractBaseUser,
то необходимо определить собственный класс ModelAdmin
В этом случае можно создать подкласс стандартного
django.contrib.auth.admin.UserAdmin; однако необходимо будет переопределить
любое из определений, которые относятся к полям в
django.contrib.auth.models.AbstractUser, которые не относятся к
пользовательскому классу пользователя


Apps

1. За что отвечает класс apps.AppConfig?
Django проект - это набор приложений, которые работают вместе для представления
какого-то функционала. Это набор изприложений, который разработали мы или другие
разработчики.

Полный набор таких приложений мы можем наблюдать в файле settings.py в
переменной INSTALLED_APPS.

Когда сервер приложений запускается, он загружает параметры, котрые определены
для проекта. Переменная окружения DJANGO_SETTINGS_MODULE определяет эти настройки
для среды.

Процесс загрузки включает в себя загрузку конфигураций URL адресов приложений,
создание древовидной структуры URL адресов. Прежде чем он выполнит эту или любую
другую settings задачу, он должен знать обо всех приложениях этого проекта.

Для этого сервер приложения берет INSTALLED_APPS и загружет или создает AppConfig
объект для каждого приложения. Эта коллеция AppConfig затем в дальнейшем
сохраняется в экземпляре App класса. Этот App экземпляр называется главным
реестром приложений.

Используя оболочку Django мы можем взаимодействовать с этим реестром, получать
AppConfig любого приложения в проекте Django.

Все объекты AppConfig имеют 2 важных аттрибута: name и label.

Когда мы запускаем команду для создания нового проекта:
python manage.py startapp app_name

django создает для нас следующую структуру приложения:
app_name/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    models.py
    tests.py
    views.py

В файле apps.py будет находитсья настройка нашего приложения, а именно аттрибут
name приложения.  name атрибут — это полный путь импорта к приложению.
Например для нашего созданного приложения достаточно просто сделать
import app_name

для auth приложения Django этого будет недостаточно:
import django.contrib.auth

Экземпляр AppConfig также можно использовать для доступа ко всем моделям
в приложении, используя методы get_models() и get_model(model_name).

AppConfig это класс в приложении, который содержит метаданные о приложении.


2. В каких случая надо определять этот класс?
Его желательно определять во всех случаях, особенно, если приложение может
использовать несколько настроек


3. В settings.INSTALLED_APPS можно прописать два варианта, пояснить
как они работают и как правильно:
 - 'my_app.apps.MyAppConfig'
 - 'my_app'
Если мы не укажем AppConfig в INSTALLED_APP самостоятельно,
тогда Django будет искать переменную default_app_config в модуле,
как об этом сказано в документации.

AppConfig могут быть определны где угодно, но есть определенное соглашение, по
которому все настройки приложений находятся в apps.py и описаны в AppConfig классе.

Если конфигурация приложения определена вне его пределов, тогда в этой ситуации
INSTALLED_APPS должен содержать пунктирный путь к классу конфигурации, и,
следовательно, не может быть обнаружен автоматически.


4. За что отвечает label?
Краткое название приложения
Атрибут label может быть объявлен в AppConfig приложения, а может и не быть
объявлен. В таком случае, он будет сгенерирован из аттрибута name.
Это значение должно быть уникальным для всего проекта Django.
Этот атрибут позволяет переименовать приложение, когда два приложения имеют
конфликтующие метки.


5. За что отвечает verbose_name?
Удобочитаемое имя приложения


ORM

1. Что такое related_name?
Когда мы создаем внешний ключ, мы связываем две модели вместе.
Модель с ForeignKey() полем использует имя поля для поиска другой модели.
Он также неявно добавляет в связанную модель член, ссылающийся на эту модель.

Здесь возможны три сценария:
- Не указывать related_name
Если не укажем имя, django создаст его по умолчанию
Имя по умолчанию — имя отношения + _set.

- Укажите пользовательское значение
related_name="something".

- Запретить создание обратной ссылки
related_name="+".


2. Что такое on_delete?
Это настройка поведения, которое должно быть принято при удалении указанного
объекта. Существует семь возможных вариантов поведения:

- CASCADE
Когда объект, на который имеется ссылка, удаляется, все объекты,
ссылающиеся на этот объект, также будут удалены.

- PROTECT
Предотвращает удаление указанного объекта, если есть объекты,
ссылающиеся на этот объект.

- RESTRICT
RESTRICT похож на PROTECT. Удаление ссылочного объекта разрешено,
если ссылающиеся объекты и ссылочный объект ссылаются на какой-либо другой
общий объект в связи CASCADE.

- SET_NULL
Когда объект, на который указывает ссылка, удаляется, то объект,
на который указывает ссылка, для всех объектов ссылки устанавливается в NULL.
Эта связь требует, чтобы поле объекта, на которое указывает ссылка,
допускало значение NULL.

- SET_DEFAULT
Когда объект ссылки удаляется, тогда объект ссылки для всех объектов ссылки
устанавливается в значение по умолчанию.

- SET()
SET () точно такой же, как SET_DEFAULT.
Единственное отличие состоит в том, что в SET() мы можем передать вызываемый
объект, который будет вызываться для всех ссылающихся объектов,
если указанный объект будет удален.

- DO_NOTHING
Когда объект, на который имеется ссылка, удален, объект, на который указывает
ссылка, не будет изменен для всех объектов ссылки. Другими словами, ничего
не будет сделано для обработки последствий удаления.


3. В чем отличие OneToOne и ForeignKey?
ForeignKey это связь многие-к-одному
OneToOne это связь один-к-одному.

Концептуально OneToOne похоже на ForeignKey с парметром unique=True,
но «обратная» сторона отношения напрямую возвращает один объект.

Для OneToOne можно не задавать related_name, так как Django само создает
название поля, совпадающего с названием модели


Pipenv

1. Как создать окружение с конкретной версией Python?
- если не установлен пакет pipenv
    python3 -m pip install pipenv
- заходим в папку с проектом и создаем виртуальное окружение
    pipenv --python 3.10


2. Как установить пакет в окружение?
    pipenv install django==1.10
при этом наш устанавливаемый пакет автоматически занесется в pipfile


3. Как подключиться к окуружению?
    pipenv shell


4. Как выполнить команду используя окружение, но не подключаясь к нему?
    pipenv run python yourapplication.py

5. Что такое lock файл?
Допустим, у нас все работает в локальной среде разработки,
и мы готовы приступить к переносу в рабочую среду.
Для этого нам нужно заблокировать свою среду, чтобы убедиться, что у нас
будет все то же самое в рабочей среде:
$ pipenv lock
Эта команда создаст/обновит файл Pipfile.lock, который вам никогда не придется
(и никогда не нужно) редактировать вручную. Вы всегда должны использовать
только сгенерированный файл.
В файле блокировки записаны все зависимости, делая снимок всех версий пакетов
(аналогично результату pip freeze).
Этот файл включает детерминированные зависимости, с указанными точными
требованиями для воспроизведения в виртуальной среды. Он содержит точные версии
для пакетов и их хеши для более безопасной проверки.
Синтаксис этого файла — JSON


6. Как установить пакеты в dev раздел, не затрагивает production пакеты?
    pipenv install pytest --dev
Использование аргумента —dev поместит зависимость в специальную папку
[dev-packages] в Pipfile. Зависимости размещенной в этой папке будут
устанавливаются только в том случае, если вы укажете аргумент
—dev в pipenv install.
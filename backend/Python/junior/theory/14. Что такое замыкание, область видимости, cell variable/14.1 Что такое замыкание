В широком смысле замыкание (closure) в программировании — это функция,
в теле которой присутствуют ссылки на переменные, объявленные вне тела этой
функции в окружающем коде и не являющиеся ее параметрами.

Перед тем как перейти к рассмотрению примеров реализации замыканий на Python,
для начала вспомним тему "область видимости переменных".

Обычно, по области видимости, переменные делят на глобальные и локальные.
Глобальные существует в течении всего времени выполнения программы,
а локальные создаются внутри методов, функций и прочих блоках кода, при этом,
после выхода из такого блока переменная удаляется из памяти.

Что касается Python, то тут выделяют четыре области видимости для переменных:

- local
    Эту область видимости имеют переменные, которые создаются и используются
    внутри функций.

    def test(a):
        x = 2
        return x + a

    print(test(4)) # получим 6
    print(x) # при попытке обратиться к x оплучаем ошибку

- enclosing
    Суть данной области видимости в том, что внутри функции могут быть
    вложенные функции и локальные переменные, так вот локальная переменная
    функции для ее вложенной функции находится в enclosing области видимости.

    def test(a):
        x = 2

        def test_print():
            print(f'x = {x}')
            return x + a

        return test_print()

    test(4) # выведет 'x = 2' и следующей строкой результат => 6
    В данном случае переменная x имеет область видимости enclosing для
    функции test_print().

- global
    Переменные области видимости global – это глобальные переменные уровня
    модуля (модуль – это файл с расширением .py). Доступ к переменным, объявленные
    на этом уровне видимости можно получить откуда угодно внутри модуля.
    В случае, если мы импортируем модуль внутрь другого модуля, то для переменной
    уже не будет области видимости global.

- build-in
    Это уровень Python интерпретатора. В рамках этой области видимости
    находятся функции open, len и т.п., также туда входят исключения.
    Эти сущности доступны в любом модуле Python и не требуют предварительного
    импорта. Built-in – это максимально широкая область видимости.

Каждый раз, когда мы вызываем функцию, у нее создаются локальные переменные
(если они у нее есть), а после завершения – уничтожаются, при очередном вызове
эта процедура повторяется.

Можно ли сделать так, чтобы после завершения работы функции, часть локальных
переменных не уничтожалась, а сохраняла свои значение до следующего запуска?
Да, это можно сделать!

    def test(a):
        x = 2

        def test_print():
            print(f'x = {x}')
            return x + a

        return test_print # возвращаем не вызов функции, а ссылку на эту функцию

    f = test(10)
    f() # а здесь вызываем эту функцию

Когда у нас есть глобальная ссылка f, на внутреннее локальное окружение
вложенной функции test_print, то это окружение продолжает существовать, оно не
удаляется автоматически сборщиком мусора. А вместе слокальным внутренним окружением
будет и продолжать существовать внешнее оркужение. У каждой переменной внутреннего
окружения есть явная или неявная ссылка на внешнее окружение:
    f -> test_print -> test -> внейшний модуль (*.py)

При каждом вызове внешнего окружения будет создаваться свое уникальное независимое
локальное окружение.

MRO – порядок разрешения методов в Python

Если один класс унаследован от другого, то он от него перенимает себе методы
и атрибуты своего родителя. Те методы, которые мы не переопределяли -
останутся родительскими. Таким образом, когда вызывается метод экземпляра класса,
Python должен посмотреть, есть ли в нем этот метод. Если есть – он и будет вызван,
а если его нет, то ему придется проверить классы-родители данного класса.

Сложнее ситуация становится, когда иерархия классов разрастается.
Не будем забывать, что Python поддерживает множественное наследование,
что сделает граф отношений между классами весьма запутанным.
Методы с одинаковыми именами могут быть определены в любых классах из всей иерархии.

Сможет сходу назвать порядок поиска методов в этой иерархии?
Воспользуемся методом mro(): аббревиатура MRO – method resolution order.

Это порядок разрешения методов в Python.
Тоже самое относится не только к методам, но и к прочим атрибутам класса,
так как методы – это частный случай более общего понятия «атрибут».

Метод класса mro() возвращает нам список классов ровно в том порядке,
в котором Python будет искать методы в иерархии классов пока не найдет нужный
или не выдаст ошибку.

Для более сложных иерархий потребуется специальный алгоритм.

Здесь стоит упомянуть алгоритм C3-линеаризации.

Какие критерии должны быть для алгоритма разрешения методов?

- Каждый класс должен входить в список ровно 1 раз.
- Если какой-то класс D наследуется от нескольких классов,
  допустим: (class D(A, B, C):), в таком же порядке они должны
  появиться в MRO. D -> ... -> A -> ... -> B -> ... -> C -> ...
  Между ними могут оказаться и другие классы, но исходный порядок должен быть
  соблюден.
- Родители данного класса должны появляться по порядку старшинства.
  Сначала идут непосредственные родители, потом дедушки и бабушки, но не наоборот.

Алгоритм, который удовлетворяет этим условиям был предложен в 1996 года и
называется C3 superclass linearization.

Линеаризация в данном случае – это процесс превращения графа наследования в
плоский список. А С3 он называется из-за наличия трех основных свойств.
Важнейшее свойство здесь – это монотонность – это свойство, которое требует
соблюдения в линеаризации класса-потомка того же порядка следования
классов-прародителей, что и в линеаризации класса-родителя.

Когда нельзя линеаризовать?
class X:
class Y:
class A(X, Y):
class B(Y, X):
class G(A, B):
Для A порядок X -> Y, а для B – обратный Y -> X.
Класс G обязан удовлетворить обоим порядкам наследования, что невозможно,
так как они противоречат друг другу. Возникнет ошибка в строке объявления
класса G

class X:
class Y(X):
class A(X, Y):
Класс X наследуется дважды, и куда мы его не поместили в цепочке MRO,
он либо нарушит правило старшинства (A -> X -> Y -> object),
либо порядка наследования (A -> Y -> X -> object).

Как задать свой порядок MRO?
Это возможно, используя метаклассы. Для «конфликтного» класса мы определим
особый метакласс, который переопределяет явно метод mro(), указывая вручную,
какой именно должен быть порядок разрешения методов.
На первом «неразрешимом» примере решение будет такое:
class X: ...
class Y: ...
class A(X, Y): ...
class B(Y, X): ...

class MyMRO(type):  # наследование type = это метакласс
    def mro(cls):
        return (cls, A, B, X, Y, object)  # явно задаем порядок!

class G(A, B, metaclass=MyMRO):
    ...

print_mro(G)  # G -> A -> B -> X -> Y -> object
# никаких ошибок!


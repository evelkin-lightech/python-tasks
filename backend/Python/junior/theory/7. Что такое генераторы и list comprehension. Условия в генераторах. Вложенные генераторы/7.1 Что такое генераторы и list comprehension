Для начала стоит ввести определение итератора.

Итератор — это интерфейс, предоставляющий доступ к элементам коллекции
(массива или контейнера).

Важно отметить, что итератор только предоставляет доступ,
но не выполняет итерацию по ним. Тему итераторов можно разбить на три части:
- Итерируемый объект
- Итератор
- Итерация

Итерируемым объектом в Python называется любой объект,
имеющий методы __iter__ или __getitem__, которые возвращают итераторы или
могут принимать индексы. В итоге итерируемый объект это объект,
который может предоставить нам итератор.

Итератором в Python называется объект, который имеет метод next (Python 2)
или __next__.

Итерация - это процесс перебора элементов объекта в цикле.

Генераторы это итераторы, по которым можно итерировать только один раз.
Так происходит поскольку они не хранят все свои значения в памяти,
а генерируют элементы "на лету". Генераторы можно использовать с циклом
for или любой другой функцией или конструкцией, которые позволяют итерировать
по объекту. В большинстве случаев генераторы создаются как функции.
Тем не менее, они не возвращают значение также как функции (т.е. через return),
в генераторах для этого используется ключевое слово yield.
Вот простой пример функции-генератора:
    def generator_function():
        for i in range(10):
            yield i

    for item in generator_function():
        print(item)

Генераторы хорошо подходят для расчета больших наборов результатов
(при использовании вложенных циклов), где не хотелось бы выделять память
для хранения всех результатов одновременно.

Функция next() - позволяет нам переходить к следующему элементу коллекции
После прохождения по всем значениям next() начала вызывать исключение
StopIteration

List comprehension — это упрощенный подход к созданию списка,
который задействует цикл for, а также инструкции if-else для определения того,
что в итоге окажется в финальном списке:
    nums = [n for n in range(1,6)]

Разница между списком и генератором в Python:
- список сразу удерживает в памяти определенное число значений.
  А генератор в каждый отдельный момент удерживает только одно значение — то,
  которое он возвращает. Вот почему генераторы требуют куда меньше памяти.
  Когда мы применяем генератор, нам также не приходится ждать рендеринга
  всех значений.

Разница между генератором и функцией в Python:
Чтобы разобраться в различиях между генераторами и функциями,
давайте сначала разберем разницу между ключевыми словами return и yield.

Когда интерпретатор доходит до ключевого слова return, выполнение функции
полностью прекращается. Но когда он доходит до ключевого слова yield,
программа приостанавливает выполнение функции и возвращает значение в
итерируемый объект. После этого интерпретатор возвращается к генератору,
чтобы повторить процесс для нового значения. Кроме того, при прекращении
выполнения функции ее локальные переменные стираются.

Генератор выражения
Мы можем легко создать выражение генератора без использования
пользовательской функции. Это то же самое, что и лямбда-функция,
которая создает анонимную функцию; выражения генератора создают анонимную
функцию генератора.

Представление выражения генератора похоже на понимание списка Python.
Единственное отличие состоит в том, что квадратные скобки заменены круглыми
скобками. Понимание списка вычисляет весь список, тогда как выражение
генератора вычисляет один элемент за раз.
    list = [1,2,3,4,5,6,7]

    # List Comprehension
    z = [x**3 for x in list]

    # Generator expression
    a = (x**3 for x in list)
list comprehension вернет список элементов в третьей степени,
тогда как выражение генератора вернет ссылку на вычисленное значение.
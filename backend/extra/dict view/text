Сегодня речь пойдет о "Dictionary view objects" в Python (объекты
представления словаря)

Для начала освежим в памяти что же такое словарь:

Словарь (dictionary) - это неупорядоченная коллекция произвольных объектов с
доступом по ключу. Его по другому еще называют "ассоциативным массивом", но так
как в Python нет такого понятия как "массив", поэтому по другому можно сказать что
это "ассоциативный спискок".

Для примера создадим простой словарь, состоящий из ключей - имен людей, а в
качестве значения этих ключей будут их номера телефонов:
    constacts = {
        'Sam': '+7(900)135-06-20',
        'Jack': '+380-9994-1293-33',
        'Smith': '+1-2342-293-330',
    }

Итак, некоторые методы словаря возвращают объект представления.

Что это за методы:
- dict.keys()
- dict.values()
- dict.items()

dict.keys() возвращает представление всех ключей словаря:
    names = contacts.keys()
    print(names)

dict.values() возвращает представление всех значений словаря:
    phones = contacts.values()
    print(phones)

Метод items() словаря возвращает итерируемый объект представления,
предлагающий как ключи, так и значения:
    print(contacts.items)

Данные методы взяты из PEP 3106: «Обновление dict.keys(), .values() и .items()».
В Python 2 эти методы возвращали объекты списка вместо объектов представления
словаря.

При помощи данных методов мыможем получить динамическое представление записей
словаря. Это означает, что при изменении словаря представление отражает эти
изменения. Скажем, мы поменяем ключи словаря или поменяем значение по этим
ключам, или добавим новую пару ключ/значение - наши представления отразят
эти изменения. Нужно понимать, что это не копия словаря - ключ/значение.

В чем приемущество использования таких представлений:
- одним из ключевых приемуществ является то, что представление (например,
dict_keys), использует только небольшой и фиксированный объем памяти и требует
небольшого и фиксированного количества процессрного времени, поскольку не
создается список ключей. Представления позволяют получить доступ к
структуре данных, не копируя ее.

Нужно помнить, что мы не можем напрямую редактировать представления:
вместо этого мы по-прежнему будем редактировать словарь.

Так же, стоит обратить внимание, что объекты представления словаря имеют
свои собственные типы. Они не являются объектами списка или объектами кортежа.
    print(type(names))              # dict_keys
    print(type(phones))             # dict_values
    print(type(contacts.items()))   # dict_items

Что мы можем делать с объектами представлений словаря?
Существуют следующие мтоды для обработки представлений словаря:
- len(dictview)
  возвращает количество элементов представления:
    len(phones)
- iter(dictview)
  возвращает иттератор для всех ключей, значений или элементов dict obj view:
    i = iter(names)
    next(i)
  все элементы будут проитерированы в том порядке, в котором они были добавлены в
  словарь, и благодаря этому, итерируя dict_items objecs мы можем, воспользовавшись
  функцией zip() создавать пары ключ/значение:
    pairs = zip(persons.values(), persons.keys())
        или при помощи геренраторов списка
    pairs = [(v, k) for (k, v) in persons.items()]
- x in dictview
  данная конструкция позволяет проверять наличие ключей, значений, элементов
  в dictview и возвращет True/False:
    'Sam' in names
    '911' in phones
    ('Sam','79001350620') in items
- reversed(dictview) был включен в Python v3.8
  Возвращает обратный итератор по ключам, значениям или элементам словаря.
  Представление будет повторяться в порядке, обратном вставке:
    rv = reversed(names)
    next(rv)
  работает по аналогии с методом iter(), но в обратном порядке.



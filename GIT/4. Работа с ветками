Ветка - это изолированный поток разработки, коммиты которых не видно из
других веток

При инициализации 1 коммита git автоматически создает ветку master.

git branch
    показывает текущую ветку

git branch -v
    показывает текущую ветку и коммит, указывающий на эту самую ветку

в git репозитории есть файл HEAD, в котором хранится ссылка на текущую ветку
например:
    ref: refs/heads/master

Когда происходит commit, git проверяет на что указывает HEAD.
HEAD указывает на master, а мастер содержит идентификатор коммита.

git branch <name>
    создание новой ветки с именем <name>

git checkout <name>
    переключение на ветку <name>

git checkout -b <name>
    создает и переключается на ветку <name>

git checkout --force <branch>
git checkout --f <branch>
    в случае, если имеются назакомиченные изменения, а есть необходимость
    переключиться на ветку можно воспользоваться данной конструкцией. При этом
    все незакомиченные изменения будут перезаписаны (сброшены)

git checkout -f HEAD
git checkout -f
    сбрасывает все незакомиченные изменения в текущей ветке


git stash
    заносит все незакомиченные изменения в стэш

git stash list
    просмотр списка стэша

git stash drop <index>
    удаляет один из элементов стэш-списка по индексу

git stash apply <index>
    применяет элемент стэш-списка по индексу

git stash pop
    применяет последний элемент стэш-списка и удаляет его из этого списка

git branch -f <branch_name> <commit>
git checkout -B <branch_name> <commit>
    откат ветки <branch_name> к указанному <commit>
    если ветки нет, git создаст ее

git checkout <commit>
    переключение HEAD на конкретный <commit>
    при выполнении данной конструкции возможно git высветит предупреждение о
    'detached HEAD', т к HEAD указывает не на ветку, а на <commit>

git cherry-pick <commit>
    копирование <commit> на текущую ветку

git checkout <commit> <file>
    переключение на определенный <commit> для восстановления определенного
    <file>

git reset <file>
    удаление из индекса для конкретного <file>

git checkout -- <path>
    все что идет после -- git воспринимает как путь

git log
    просмотр изменений проекта

git log --oneline
    вывод log в более компактном виде

git log <branch> --oneline
    просмотр изменений в ветке <branch> в компактном виде

git merge <branch>
git checkout -B <current_branch> <needed_branch>
    слияние текущей ветки с веткой <branch>
    по умолчанию будет использован алгоритм 'быстрой перемотки' (fast forward),
    который подразумевает что вершина текущей ветки обновляется до вершины
    ветки <branch>.
    При слиянии ветки через checkout произойдет тоже самое, но необходимо
    указывать текущую ветку и ветку, изменения которой мы хотим добавить.

git branch -f <branch> ORIG_HEAD
    откатывает слияние ветки <branch> до предыдущего состояния
    git перед слиянием веток заносит в ORIG_HEAD ссылку на вершину ветки
    <branch>, далее мы к ней можем обратиться при откатывании слияния

git branch -d <branch>
    удаление ветки <branch>. Данная команда сработает, если ветка <branch>
    будет объединена с текущей веткой.

git branch -D <branch>
    удаление ветки <branch>, даже если ветки не объединены

git branch <branch> <commit>
    если было произведено случайное удаление ветки (недавно), то можно все
    вернуть, создав ветку <branch> с тем де именем и указав идентификатор
    <commit>

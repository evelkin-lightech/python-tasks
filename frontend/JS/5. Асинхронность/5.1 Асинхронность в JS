JS это однопоточный язык программирования, т е все команды выполняются
в 1 потоке, синхронно, строчкой за строчкой.

Если мы захотим выполнить 2 функции - у нас это не получится, потому что нам
необходимо будет как минимум 2 потока.

Код JS выполняется в браузере, который может предоставить для такой ситуации
WebAPI. Именно в этом интерфейсе реализованы все асинхронные методы.

Из основного потока JS мы вызываем асинхронные методы, которые предоставляет
WebAPI. При этом поток JS не блокируется, метод  выполняется на стороне браузера,
после мы можем получить ответ и обработать его.

Чтобы понять, что такое асинхронность в JS нужно ввести понятие call stack.
Представим картину, что на стол ставят книги - одну за одной, причем
последующую кладут на предыдущую. Затем у нас возникла необходимость вытащить книгу
из середины стопки. Для этого мы должны будем снять все книги, которые будут
лежать над ней. И так, пока не дойдет до нужной книги. В JS работает все также.

У нас есть call stack - это стек вызова наших функций. Т е сначала вызывается
одна функция, затем если внутри есть вызов еще одной функции, то она добавляется
в стек сврху предыдущей функции. И т д по аналогии.

Когда самая верхняя функция завершается и возвращает значение (является выполненой),
то она убирается из стека. И т д по аналогии, пока стек не будет очищен.

Далее, рассмотрим пример:
    console.log('Start');

    console.log('Middle');

    setTimeout(function () {
        console.log('timeout')
    }, 2000);

    console.log('End')
Бразуер проходит (интерпретирует) по строкам скрипта и поочередно выполняет строку за строкой,
занося функции в call stack.

Функция setTimeout() не входит в спецификации JS, а относится к WebAPI, что это
значит: это означает, что как только браузер дойдет до строки с данной конструкцией,
он занесет выполнение нашей функции в WebAPI, зарегистрируя в call stack при
этом, что функция, находящаяся внутри нее (console.log('timeout')),
должна выполнятся через указанное время. При этом блокировки выполнения скрипта
(потока) не будет, и код будет выполняться дальше. На выходе выполнения скрипта
получим:
    'Start'
    'Middle'
    'End'
    'timeout' // через 2 секунды

Почему программа не блокируется? Почему не ждет результатов выполнения функции,
указанной в setTimeout()? Здесь кроется простой концеп, который называется
Event Loop.

Как Event Loop работает: когда интерпретатор доходит до блока (части кода) с
асинхронными функциями, он закидывает весь блок в стэк. В стеке происходит
некая инициализация, что в конструкции присутсвует setTimeout() - а это браузерная
API (WebAPI), поэтому он исключает его из стека, но регистриует вложенную
в него функцию console.log('timeout') и ждет, когда браузерный сторонний API
выполнит setTimeout(). Когда данный метод будет выполнен, функция,
которую мы зарегистрировали console.log('timeout'), попадает в очередь, где
работает очень простой цикл, который пробегается по этой очереди, и, если видит,
что функция готова, то он закидывает ее обратно в стек и выполняет ее.

Таким образом мы не блокируем поток выполнения скрипта.

Речь идет не только о setTimeout(), речь идет о любых асинхронных операциях.

